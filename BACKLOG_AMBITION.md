# Capability Expansion Backlog

## P0: Add web research capability to workers and strategist
Workers currently operate in a filesystem-only bubble. They cannot look up API docs, check library versions, read GitHub issues, or research best practices. The strategist proposes objectives based solely on static code analysis, missing external context like new Claude API features, community patterns, or competitor approaches. Add a web research tool (via MCP or direct subprocess) that workers and the strategist can invoke. The strategist should be able to research the state of the art before proposing objectives. Workers should be able to look up documentation while implementing. This is the difference between a code monkey and an engineer. Start with: (1) a `WebResearchTool` wrapper that workers can call via MCP, (2) inject web search results into strategist context when proposing objectives, (3) allow the planner to flag units as "needs-research" which get web access enabled.
**Files**: src/mission_control/strategist.py, src/mission_control/worker.py, src/mission_control/mcp_server.py

## P0: Implement strategist ambition ladder with capability-expanding objectives
The strategist currently proposes objectives by looking at backlog items, which are all internal fixes and quality improvements discovered by static analysis. It never proposes objectives that expand the system's capabilities because the discovery engine only finds bugs and code smells. Add an ambition ladder to the strategist: (1) Level 1: fix bugs and quality issues (current behavior), (2) Level 2: improve existing features (adaptive concurrency, better planning), (3) Level 3: add new capabilities that compound (web research, browser testing, multi-repo support, external integrations), (4) Level 4: meta-improvements that make the system better at improving itself. The strategist should aim for the highest level that's feasible given current state. When all Level 1-2 items are done, it MUST escalate to Level 3-4 instead of finding more lint to fix. Include a "capability gap analysis" step where the strategist compares what the system can do vs what it could do.
**Files**: src/mission_control/strategist.py, src/mission_control/auto_discovery.py

## P0: Add browser automation for live testing of built software
Mission control builds software but never tests it the way a user would. It runs pytest but never opens a browser, clicks through flows, or validates that a web app actually works. Integrate browser automation (via Playwright MCP or Claude's computer use) so that: (1) after deploying/building a web project, workers can launch a browser and validate the UI, (2) verification includes visual/functional checks not just unit tests, (3) the system can catch issues that only manifest in a real browser (CSS broken, API calls failing, auth flows broken). This is critical for mission control to autonomously ship production software, not just pass tests.
**Files**: src/mission_control/worker.py, src/mission_control/state.py, src/mission_control/config.py

## P1: Add external data ingestion for informed decision-making
The strategist and planner make decisions in a vacuum. They don't know about: new model releases (Claude 4.5 capabilities), API changes, dependency vulnerabilities, production metrics, user feedback, or market signals. Build an external data ingestion pipeline that: (1) periodically fetches relevant signals (GitHub release feeds, npm/pypi advisories, configured RSS/webhook sources), (2) stores them in a context table, (3) injects relevant signals into strategist and planner prompts. Example: if a new Claude model drops with better tool use, the strategist should know and propose objectives that leverage it. If a dependency has a CVE, it should prioritize upgrading.
**Files**: src/mission_control/strategist.py, src/mission_control/db.py, src/mission_control/config.py

## P1: Implement multi-project orchestration with cross-project learning
Mission control currently improves one repo at a time. But Danny has multiple projects that share patterns (MCP servers, FastAPI apps, agent infrastructure). Add multi-project support: (1) the strategist can see all registered projects and their state, (2) learnings from one project (e.g., "this auth pattern works well") transfer to others, (3) the system can propose cross-project objectives like "upgrade all projects to use the new Claude SDK" or "extract the common MCP server pattern into a shared library". The registry infrastructure already exists but isn't wired into the strategist.
**Files**: src/mission_control/strategist.py, src/mission_control/registry.py, src/mission_control/config.py

## P1: Add self-benchmarking and capability measurement
The system has no way to measure whether it's getting better. Add benchmarking: (1) track metrics per mission (wall time, cost, units completed, merge conflict rate, test pass rate, lines changed), (2) track capability metrics (can it build a web app from scratch? can it debug a production issue? can it handle a multi-file refactor without conflicts?), (3) run periodic capability probes (small challenge tasks) to measure improvement over time. The strategist should use these metrics to identify the biggest capability gaps and prioritize accordingly. Without measurement, the system can't distinguish between busywork and real improvement.
**Files**: src/mission_control/mission_report.py, src/mission_control/strategist.py, src/mission_control/db.py

## P2: Implement speculative execution with rollback for high-risk changes
Currently every unit is a committed change. For ambitious changes (new features, architectural shifts), the system should be able to speculatively execute: (1) run the change in an isolated branch, (2) run extended verification (not just pytest but integration tests, benchmarks, browser tests), (3) only merge if all checks pass, otherwise rollback and try a different approach. This lets the system attempt bolder changes without risk. The speculation infrastructure partially exists (speculation_score, speculation_parent_id fields in work_units) but isn't wired up.
**Files**: src/mission_control/continuous_controller.py, src/mission_control/green_branch.py
